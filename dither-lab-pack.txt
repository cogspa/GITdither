This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
public/
  gif.worker.js
  vite.svg
src/
  assets/
    react.svg
  App.css
  App.jsx
  index.css
  main.jsx
.gitignore
eslint.config.js
index.html
package.json
README.md
vite.config.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="public/gif.worker.js">
// gif.worker.js 0.2.0 - https://github.com/jnordberg/gif.js
(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){var NeuQuant=require("./TypedNeuQuant.js");var LZWEncoder=require("./LZWEncoder.js");function ByteArray(){this.page=-1;this.pages=[];this.newPage()}ByteArray.pageSize=4096;ByteArray.charMap={};for(var i=0;i<256;i++)ByteArray.charMap[i]=String.fromCharCode(i);ByteArray.prototype.newPage=function(){this.pages[++this.page]=new Uint8Array(ByteArray.pageSize);this.cursor=0};ByteArray.prototype.getData=function(){var rv="";for(var p=0;p<this.pages.length;p++){for(var i=0;i<ByteArray.pageSize;i++){rv+=ByteArray.charMap[this.pages[p][i]]}}return rv};ByteArray.prototype.writeByte=function(val){if(this.cursor>=ByteArray.pageSize)this.newPage();this.pages[this.page][this.cursor++]=val};ByteArray.prototype.writeUTFBytes=function(string){for(var l=string.length,i=0;i<l;i++)this.writeByte(string.charCodeAt(i))};ByteArray.prototype.writeBytes=function(array,offset,length){for(var l=length||array.length,i=offset||0;i<l;i++)this.writeByte(array[i])};function GIFEncoder(width,height){this.width=~~width;this.height=~~height;this.transparent=null;this.transIndex=0;this.repeat=-1;this.delay=0;this.image=null;this.pixels=null;this.indexedPixels=null;this.colorDepth=null;this.colorTab=null;this.neuQuant=null;this.usedEntry=new Array;this.palSize=7;this.dispose=-1;this.firstFrame=true;this.sample=10;this.dither=false;this.globalPalette=false;this.out=new ByteArray}GIFEncoder.prototype.setDelay=function(milliseconds){this.delay=Math.round(milliseconds/10)};GIFEncoder.prototype.setFrameRate=function(fps){this.delay=Math.round(100/fps)};GIFEncoder.prototype.setDispose=function(disposalCode){if(disposalCode>=0)this.dispose=disposalCode};GIFEncoder.prototype.setRepeat=function(repeat){this.repeat=repeat};GIFEncoder.prototype.setTransparent=function(color){this.transparent=color};GIFEncoder.prototype.addFrame=function(imageData){this.image=imageData;this.colorTab=this.globalPalette&&this.globalPalette.slice?this.globalPalette:null;this.getImagePixels();this.analyzePixels();if(this.globalPalette===true)this.globalPalette=this.colorTab;if(this.firstFrame){this.writeLSD();this.writePalette();if(this.repeat>=0){this.writeNetscapeExt()}}this.writeGraphicCtrlExt();this.writeImageDesc();if(!this.firstFrame&&!this.globalPalette)this.writePalette();this.writePixels();this.firstFrame=false};GIFEncoder.prototype.finish=function(){this.out.writeByte(59)};GIFEncoder.prototype.setQuality=function(quality){if(quality<1)quality=1;this.sample=quality};GIFEncoder.prototype.setDither=function(dither){if(dither===true)dither="FloydSteinberg";this.dither=dither};GIFEncoder.prototype.setGlobalPalette=function(palette){this.globalPalette=palette};GIFEncoder.prototype.getGlobalPalette=function(){return this.globalPalette&&this.globalPalette.slice&&this.globalPalette.slice(0)||this.globalPalette};GIFEncoder.prototype.writeHeader=function(){this.out.writeUTFBytes("GIF89a")};GIFEncoder.prototype.analyzePixels=function(){if(!this.colorTab){this.neuQuant=new NeuQuant(this.pixels,this.sample);this.neuQuant.buildColormap();this.colorTab=this.neuQuant.getColormap()}if(this.dither){this.ditherPixels(this.dither.replace("-serpentine",""),this.dither.match(/-serpentine/)!==null)}else{this.indexPixels()}this.pixels=null;this.colorDepth=8;this.palSize=7;if(this.transparent!==null){this.transIndex=this.findClosest(this.transparent,true)}};GIFEncoder.prototype.indexPixels=function(imgq){var nPix=this.pixels.length/3;this.indexedPixels=new Uint8Array(nPix);var k=0;for(var j=0;j<nPix;j++){var index=this.findClosestRGB(this.pixels[k++]&255,this.pixels[k++]&255,this.pixels[k++]&255);this.usedEntry[index]=true;this.indexedPixels[j]=index}};GIFEncoder.prototype.ditherPixels=function(kernel,serpentine){var kernels={FalseFloydSteinberg:[[3/8,1,0],[3/8,0,1],[2/8,1,1]],FloydSteinberg:[[7/16,1,0],[3/16,-1,1],[5/16,0,1],[1/16,1,1]],Stucki:[[8/42,1,0],[4/42,2,0],[2/42,-2,1],[4/42,-1,1],[8/42,0,1],[4/42,1,1],[2/42,2,1],[1/42,-2,2],[2/42,-1,2],[4/42,0,2],[2/42,1,2],[1/42,2,2]],Atkinson:[[1/8,1,0],[1/8,2,0],[1/8,-1,1],[1/8,0,1],[1/8,1,1],[1/8,0,2]]};if(!kernel||!kernels[kernel]){throw"Unknown dithering kernel: "+kernel}var ds=kernels[kernel];var index=0,height=this.height,width=this.width,data=this.pixels;var direction=serpentine?-1:1;this.indexedPixels=new Uint8Array(this.pixels.length/3);for(var y=0;y<height;y++){if(serpentine)direction=direction*-1;for(var x=direction==1?0:width-1,xend=direction==1?width:0;x!==xend;x+=direction){index=y*width+x;var idx=index*3;var r1=data[idx];var g1=data[idx+1];var b1=data[idx+2];idx=this.findClosestRGB(r1,g1,b1);this.usedEntry[idx]=true;this.indexedPixels[index]=idx;idx*=3;var r2=this.colorTab[idx];var g2=this.colorTab[idx+1];var b2=this.colorTab[idx+2];var er=r1-r2;var eg=g1-g2;var eb=b1-b2;for(var i=direction==1?0:ds.length-1,end=direction==1?ds.length:0;i!==end;i+=direction){var x1=ds[i][1];var y1=ds[i][2];if(x1+x>=0&&x1+x<width&&y1+y>=0&&y1+y<height){var d=ds[i][0];idx=index+x1+y1*width;idx*=3;data[idx]=Math.max(0,Math.min(255,data[idx]+er*d));data[idx+1]=Math.max(0,Math.min(255,data[idx+1]+eg*d));data[idx+2]=Math.max(0,Math.min(255,data[idx+2]+eb*d))}}}}};GIFEncoder.prototype.findClosest=function(c,used){return this.findClosestRGB((c&16711680)>>16,(c&65280)>>8,c&255,used)};GIFEncoder.prototype.findClosestRGB=function(r,g,b,used){if(this.colorTab===null)return-1;if(this.neuQuant&&!used){return this.neuQuant.lookupRGB(r,g,b)}var c=b|g<<8|r<<16;var minpos=0;var dmin=256*256*256;var len=this.colorTab.length;for(var i=0,index=0;i<len;index++){var dr=r-(this.colorTab[i++]&255);var dg=g-(this.colorTab[i++]&255);var db=b-(this.colorTab[i++]&255);var d=dr*dr+dg*dg+db*db;if((!used||this.usedEntry[index])&&d<dmin){dmin=d;minpos=index}}return minpos};GIFEncoder.prototype.getImagePixels=function(){var w=this.width;var h=this.height;this.pixels=new Uint8Array(w*h*3);var data=this.image;var srcPos=0;var count=0;for(var i=0;i<h;i++){for(var j=0;j<w;j++){this.pixels[count++]=data[srcPos++];this.pixels[count++]=data[srcPos++];this.pixels[count++]=data[srcPos++];srcPos++}}};GIFEncoder.prototype.writeGraphicCtrlExt=function(){this.out.writeByte(33);this.out.writeByte(249);this.out.writeByte(4);var transp,disp;if(this.transparent===null){transp=0;disp=0}else{transp=1;disp=2}if(this.dispose>=0){disp=dispose&7}disp<<=2;this.out.writeByte(0|disp|0|transp);this.writeShort(this.delay);this.out.writeByte(this.transIndex);this.out.writeByte(0)};GIFEncoder.prototype.writeImageDesc=function(){this.out.writeByte(44);this.writeShort(0);this.writeShort(0);this.writeShort(this.width);this.writeShort(this.height);if(this.firstFrame||this.globalPalette){this.out.writeByte(0)}else{this.out.writeByte(128|0|0|0|this.palSize)}};GIFEncoder.prototype.writeLSD=function(){this.writeShort(this.width);this.writeShort(this.height);this.out.writeByte(128|112|0|this.palSize);this.out.writeByte(0);this.out.writeByte(0)};GIFEncoder.prototype.writeNetscapeExt=function(){this.out.writeByte(33);this.out.writeByte(255);this.out.writeByte(11);this.out.writeUTFBytes("NETSCAPE2.0");this.out.writeByte(3);this.out.writeByte(1);this.writeShort(this.repeat);this.out.writeByte(0)};GIFEncoder.prototype.writePalette=function(){this.out.writeBytes(this.colorTab);var n=3*256-this.colorTab.length;for(var i=0;i<n;i++)this.out.writeByte(0)};GIFEncoder.prototype.writeShort=function(pValue){this.out.writeByte(pValue&255);this.out.writeByte(pValue>>8&255)};GIFEncoder.prototype.writePixels=function(){var enc=new LZWEncoder(this.width,this.height,this.indexedPixels,this.colorDepth);enc.encode(this.out)};GIFEncoder.prototype.stream=function(){return this.out};module.exports=GIFEncoder},{"./LZWEncoder.js":2,"./TypedNeuQuant.js":3}],2:[function(require,module,exports){var EOF=-1;var BITS=12;var HSIZE=5003;var masks=[0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535];function LZWEncoder(width,height,pixels,colorDepth){var initCodeSize=Math.max(2,colorDepth);var accum=new Uint8Array(256);var htab=new Int32Array(HSIZE);var codetab=new Int32Array(HSIZE);var cur_accum,cur_bits=0;var a_count;var free_ent=0;var maxcode;var clear_flg=false;var g_init_bits,ClearCode,EOFCode;function char_out(c,outs){accum[a_count++]=c;if(a_count>=254)flush_char(outs)}function cl_block(outs){cl_hash(HSIZE);free_ent=ClearCode+2;clear_flg=true;output(ClearCode,outs)}function cl_hash(hsize){for(var i=0;i<hsize;++i)htab[i]=-1}function compress(init_bits,outs){var fcode,c,i,ent,disp,hsize_reg,hshift;g_init_bits=init_bits;clear_flg=false;n_bits=g_init_bits;maxcode=MAXCODE(n_bits);ClearCode=1<<init_bits-1;EOFCode=ClearCode+1;free_ent=ClearCode+2;a_count=0;ent=nextPixel();hshift=0;for(fcode=HSIZE;fcode<65536;fcode*=2)++hshift;hshift=8-hshift;hsize_reg=HSIZE;cl_hash(hsize_reg);output(ClearCode,outs);outer_loop:while((c=nextPixel())!=EOF){fcode=(c<<BITS)+ent;i=c<<hshift^ent;if(htab[i]===fcode){ent=codetab[i];continue}else if(htab[i]>=0){disp=hsize_reg-i;if(i===0)disp=1;do{if((i-=disp)<0)i+=hsize_reg;if(htab[i]===fcode){ent=codetab[i];continue outer_loop}}while(htab[i]>=0)}output(ent,outs);ent=c;if(free_ent<1<<BITS){codetab[i]=free_ent++;htab[i]=fcode}else{cl_block(outs)}}output(ent,outs);output(EOFCode,outs)}function encode(outs){outs.writeByte(initCodeSize);remaining=width*height;curPixel=0;compress(initCodeSize+1,outs);outs.writeByte(0)}function flush_char(outs){if(a_count>0){outs.writeByte(a_count);outs.writeBytes(accum,0,a_count);a_count=0}}function MAXCODE(n_bits){return(1<<n_bits)-1}function nextPixel(){if(remaining===0)return EOF;--remaining;var pix=pixels[curPixel++];return pix&255}function output(code,outs){cur_accum&=masks[cur_bits];if(cur_bits>0)cur_accum|=code<<cur_bits;else cur_accum=code;cur_bits+=n_bits;while(cur_bits>=8){char_out(cur_accum&255,outs);cur_accum>>=8;cur_bits-=8}if(free_ent>maxcode||clear_flg){if(clear_flg){maxcode=MAXCODE(n_bits=g_init_bits);clear_flg=false}else{++n_bits;if(n_bits==BITS)maxcode=1<<BITS;else maxcode=MAXCODE(n_bits)}}if(code==EOFCode){while(cur_bits>0){char_out(cur_accum&255,outs);cur_accum>>=8;cur_bits-=8}flush_char(outs)}}this.encode=encode}module.exports=LZWEncoder},{}],3:[function(require,module,exports){var ncycles=100;var netsize=256;var maxnetpos=netsize-1;var netbiasshift=4;var intbiasshift=16;var intbias=1<<intbiasshift;var gammashift=10;var gamma=1<<gammashift;var betashift=10;var beta=intbias>>betashift;var betagamma=intbias<<gammashift-betashift;var initrad=netsize>>3;var radiusbiasshift=6;var radiusbias=1<<radiusbiasshift;var initradius=initrad*radiusbias;var radiusdec=30;var alphabiasshift=10;var initalpha=1<<alphabiasshift;var alphadec;var radbiasshift=8;var radbias=1<<radbiasshift;var alpharadbshift=alphabiasshift+radbiasshift;var alpharadbias=1<<alpharadbshift;var prime1=499;var prime2=491;var prime3=487;var prime4=503;var minpicturebytes=3*prime4;function NeuQuant(pixels,samplefac){var network;var netindex;var bias;var freq;var radpower;function init(){network=[];netindex=new Int32Array(256);bias=new Int32Array(netsize);freq=new Int32Array(netsize);radpower=new Int32Array(netsize>>3);var i,v;for(i=0;i<netsize;i++){v=(i<<netbiasshift+8)/netsize;network[i]=new Float64Array([v,v,v,0]);freq[i]=intbias/netsize;bias[i]=0}}function unbiasnet(){for(var i=0;i<netsize;i++){network[i][0]>>=netbiasshift;network[i][1]>>=netbiasshift;network[i][2]>>=netbiasshift;network[i][3]=i}}function altersingle(alpha,i,b,g,r){network[i][0]-=alpha*(network[i][0]-b)/initalpha;network[i][1]-=alpha*(network[i][1]-g)/initalpha;network[i][2]-=alpha*(network[i][2]-r)/initalpha}function alterneigh(radius,i,b,g,r){var lo=Math.abs(i-radius);var hi=Math.min(i+radius,netsize);var j=i+1;var k=i-1;var m=1;var p,a;while(j<hi||k>lo){a=radpower[m++];if(j<hi){p=network[j++];p[0]-=a*(p[0]-b)/alpharadbias;p[1]-=a*(p[1]-g)/alpharadbias;p[2]-=a*(p[2]-r)/alpharadbias}if(k>lo){p=network[k--];p[0]-=a*(p[0]-b)/alpharadbias;p[1]-=a*(p[1]-g)/alpharadbias;p[2]-=a*(p[2]-r)/alpharadbias}}}function contest(b,g,r){var bestd=~(1<<31);var bestbiasd=bestd;var bestpos=-1;var bestbiaspos=bestpos;var i,n,dist,biasdist,betafreq;for(i=0;i<netsize;i++){n=network[i];dist=Math.abs(n[0]-b)+Math.abs(n[1]-g)+Math.abs(n[2]-r);if(dist<bestd){bestd=dist;bestpos=i}biasdist=dist-(bias[i]>>intbiasshift-netbiasshift);if(biasdist<bestbiasd){bestbiasd=biasdist;bestbiaspos=i}betafreq=freq[i]>>betashift;freq[i]-=betafreq;bias[i]+=betafreq<<gammashift}freq[bestpos]+=beta;bias[bestpos]-=betagamma;return bestbiaspos}function inxbuild(){var i,j,p,q,smallpos,smallval,previouscol=0,startpos=0;for(i=0;i<netsize;i++){p=network[i];smallpos=i;smallval=p[1];for(j=i+1;j<netsize;j++){q=network[j];if(q[1]<smallval){smallpos=j;smallval=q[1]}}q=network[smallpos];if(i!=smallpos){j=q[0];q[0]=p[0];p[0]=j;j=q[1];q[1]=p[1];p[1]=j;j=q[2];q[2]=p[2];p[2]=j;j=q[3];q[3]=p[3];p[3]=j}if(smallval!=previouscol){netindex[previouscol]=startpos+i>>1;for(j=previouscol+1;j<smallval;j++)netindex[j]=i;previouscol=smallval;startpos=i}}netindex[previouscol]=startpos+maxnetpos>>1;for(j=previouscol+1;j<256;j++)netindex[j]=maxnetpos}function inxsearch(b,g,r){var a,p,dist;var bestd=1e3;var best=-1;var i=netindex[g];var j=i-1;while(i<netsize||j>=0){if(i<netsize){p=network[i];dist=p[1]-g;if(dist>=bestd)i=netsize;else{i++;if(dist<0)dist=-dist;a=p[0]-b;if(a<0)a=-a;dist+=a;if(dist<bestd){a=p[2]-r;if(a<0)a=-a;dist+=a;if(dist<bestd){bestd=dist;best=p[3]}}}}if(j>=0){p=network[j];dist=g-p[1];if(dist>=bestd)j=-1;else{j--;if(dist<0)dist=-dist;a=p[0]-b;if(a<0)a=-a;dist+=a;if(dist<bestd){a=p[2]-r;if(a<0)a=-a;dist+=a;if(dist<bestd){bestd=dist;best=p[3]}}}}}return best}function learn(){var i;var lengthcount=pixels.length;var alphadec=30+(samplefac-1)/3;var samplepixels=lengthcount/(3*samplefac);var delta=~~(samplepixels/ncycles);var alpha=initalpha;var radius=initradius;var rad=radius>>radiusbiasshift;if(rad<=1)rad=0;for(i=0;i<rad;i++)radpower[i]=alpha*((rad*rad-i*i)*radbias/(rad*rad));var step;if(lengthcount<minpicturebytes){samplefac=1;step=3}else if(lengthcount%prime1!==0){step=3*prime1}else if(lengthcount%prime2!==0){step=3*prime2}else if(lengthcount%prime3!==0){step=3*prime3}else{step=3*prime4}var b,g,r,j;var pix=0;i=0;while(i<samplepixels){b=(pixels[pix]&255)<<netbiasshift;g=(pixels[pix+1]&255)<<netbiasshift;r=(pixels[pix+2]&255)<<netbiasshift;j=contest(b,g,r);altersingle(alpha,j,b,g,r);if(rad!==0)alterneigh(rad,j,b,g,r);pix+=step;if(pix>=lengthcount)pix-=lengthcount;i++;if(delta===0)delta=1;if(i%delta===0){alpha-=alpha/alphadec;radius-=radius/radiusdec;rad=radius>>radiusbiasshift;if(rad<=1)rad=0;for(j=0;j<rad;j++)radpower[j]=alpha*((rad*rad-j*j)*radbias/(rad*rad))}}}function buildColormap(){init();learn();unbiasnet();inxbuild()}this.buildColormap=buildColormap;function getColormap(){var map=[];var index=[];for(var i=0;i<netsize;i++)index[network[i][3]]=i;var k=0;for(var l=0;l<netsize;l++){var j=index[l];map[k++]=network[j][0];map[k++]=network[j][1];map[k++]=network[j][2]}return map}this.getColormap=getColormap;this.lookupRGB=inxsearch}module.exports=NeuQuant},{}],4:[function(require,module,exports){var GIFEncoder,renderFrame;GIFEncoder=require("./GIFEncoder.js");renderFrame=function(frame){var encoder,page,stream,transfer;encoder=new GIFEncoder(frame.width,frame.height);if(frame.index===0){encoder.writeHeader()}else{encoder.firstFrame=false}encoder.setTransparent(frame.transparent);encoder.setRepeat(frame.repeat);encoder.setDelay(frame.delay);encoder.setQuality(frame.quality);encoder.setDither(frame.dither);encoder.setGlobalPalette(frame.globalPalette);encoder.addFrame(frame.data);if(frame.last){encoder.finish()}if(frame.globalPalette===true){frame.globalPalette=encoder.getGlobalPalette()}stream=encoder.stream();frame.data=stream.pages;frame.cursor=stream.cursor;frame.pageSize=stream.constructor.pageSize;if(frame.canTransfer){transfer=function(){var i,len,ref,results;ref=frame.data;results=[];for(i=0,len=ref.length;i<len;i++){page=ref[i];results.push(page.buffer)}return results}();return self.postMessage(frame,transfer)}else{return self.postMessage(frame)}};self.onmessage=function(event){return renderFrame(event.data)}},{"./GIFEncoder.js":1}]},{},[4]);
//# sourceMappingURL=gif.worker.js.map
</file>

<file path="public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="src/assets/react.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>
</file>

<file path="src/App.css">
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}
</file>

<file path="src/main.jsx">
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.jsx'

createRoot(document.getElementById('root')).render(
  <StrictMode>
    <App />
  </StrictMode>,
)
</file>

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
</file>

<file path="eslint.config.js">
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{js,jsx}'],
    extends: [
      js.configs.recommended,
      reactHooks.configs.flat.recommended,
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    rules: {
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
    },
  },
])
</file>

<file path="README.md">
# React + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) (or [oxc](https://oxc.rs) when used in [rolldown-vite](https://vite.dev/guide/rolldown)) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## React Compiler

The React Compiler is not enabled on this template because of its impact on dev & build performances. To add it, see [this documentation](https://react.dev/learn/react-compiler/installation).

## Expanding the ESLint configuration

If you are developing a production application, we recommend using TypeScript with type-aware lint rules enabled. Check out the [TS template](https://github.com/vitejs/vite/tree/main/packages/create-vite/template-react-ts) for information on how to integrate TypeScript and [`typescript-eslint`](https://typescript-eslint.io) in your project.
</file>

<file path="vite.config.js">
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import { nodePolyfills } from 'vite-plugin-node-polyfills'

// https://vite.dev/config/
export default defineConfig({
  plugins: [
    react(),
    nodePolyfills({
      // Whether to polyfill `node:` protocol imports.
      protocolImports: true,
    }),
  ],
})
</file>

<file path="index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GIF DITHER LAB</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>
</file>

<file path="package.json">
{
  "name": "git-dither",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "canvas-dither": "^1.0.1",
    "chroma-js": "^3.2.0",
    "framer-motion": "^12.23.26",
    "gif-frames": "^1.0.1",
    "gif.js": "^0.2.0",
    "lucide-react": "^0.562.0",
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "vite-plugin-node-polyfills": "^0.24.0"
  },
  "devDependencies": {
    "@eslint/js": "^9.39.1",
    "@types/react": "^19.2.5",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^5.1.1",
    "eslint": "^9.39.1",
    "eslint-plugin-react-hooks": "^7.0.1",
    "eslint-plugin-react-refresh": "^0.4.24",
    "globals": "^16.5.0",
    "vite": "^7.2.4"
  }
}
</file>

<file path="src/index.css">
@import url('https://fonts.googleapis.com/css2?family=Outfit:wght@400;600;800&display=swap');

:root {
  --bg-color: #030303;
  --surface-color: rgba(15, 15, 18, 0.95);
  --border-color: rgba(255, 255, 255, 0.08);
  --primary-color: #00f2ff;
  --secondary-color: #ff00ea;
  --accent-color: #7000ff;
  --text-main: #ffffff;
  --text-dim: rgba(255, 255, 255, 0.5);
  --glass-bg: rgba(255, 255, 255, 0.02);
  --glass-blur: blur(20px);
}

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  background-color: var(--bg-color);
  color: var(--text-main);
  font-family: 'Outfit', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  -webkit-font-smoothing: antialiased;
  min-height: 100vh;
  overflow-x: hidden;
}

.app-container {
  display: flex;
  flex-direction: column;
  height: 100vh;
  background: var(--bg-color);
  overflow: hidden;
}

header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 1rem 0;
  border-bottom: 1px solid var(--border-color);
}

.logo {
  font-size: 1.5rem;
  font-weight: 800;
  background: linear-gradient(45deg, var(--primary-color), var(--secondary-color));
  -webkit-background-clip: text;
  background-clip: text;
  -webkit-text-fill-color: transparent;
  letter-spacing: -0.05em;
  line-height: 1;
}

.instructions {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  font-size: 0.75rem;
  color: var(--text-dim);
  margin-top: 6px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.instructions span {
  background: rgba(255, 255, 255, 0.03);
  padding: 2px 6px;
  border-radius: 4px;
}

.header-brand {
  display: flex;
  flex-direction: column;
}

main {
  display: flex;
  flex: 1;
  overflow: hidden;
  position: relative;
}

.preview-area {
  flex: 1;
  display: flex;
  flex-direction: column;
  position: relative;
  overflow: hidden;
  background: #000;
}

.sidebar-resizer {
  width: 4px;
  background: var(--border-color);
  cursor: ew-resize;
  transition: background 0.2s;
  z-index: 100;
}

.sidebar-resizer:hover,
.sidebar-resizer.active {
  background: var(--primary-color);
  box-shadow: 0 0 10px var(--primary-color);
}

.upload-zone {
  border: 2px dashed var(--border-color);
  border-radius: 24px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 400px;
  background: var(--glass-bg);
  backdrop-filter: var(--glass-blur);
  transition: all 0.3s ease;
  cursor: pointer;
  position: relative;
  overflow: hidden;
}

.upload-zone:hover {
  border-color: var(--primary-color);
  background: rgba(255, 255, 255, 0.05);
}

.upload-zone.dragging {
  border-color: var(--secondary-color);
  transform: scale(1.02);
}

.preview-container {
  position: relative;
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  background: black;
}

.preview-container img {
  max-width: 100%;
  max-height: 100%;
  object-fit: contain;
}

.comparison-slider {
  position: relative;
  width: auto;
  height: auto;
  overflow: hidden;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
  border-radius: 12px;
  border: 1px solid var(--border-color);
}

.compare-original {
  display: block;
  width: 100%;
  height: 100%;
  object-fit: contain;
  user-select: none;
  -webkit-user-drag: none;
  pointer-events: none;
}

.compare-output {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  object-fit: contain;
  clip-path: inset(0 0 0 var(--split));
  z-index: 2;
  user-select: none;
  -webkit-user-drag: none;
  pointer-events: none;
}

.compare-handle {
  position: absolute;
  top: 0;
  bottom: 0;
  transform: translateX(-50%);
  pointer-events: none;
  z-index: 10;
  width: 2px;
  background: white;
  display: flex;
  align-items: center;
  justify-content: center;
}

.handle-line {
  position: absolute;
  top: 0;
  bottom: 0;
  width: 2px;
  background: white;
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
}

.handle-circle {
  width: 32px;
  height: 32px;
  background: black;
  border: 2px solid white;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  z-index: 11;
  box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
}

.preview-wrapper {
  position: relative;
  display: inline-block;
  max-width: 100%;
  max-height: 100%;
}

.preview-wrapper img {
  display: block;
  max-width: 100%;
  max-height: 100%;
  object-fit: contain;
}

.selection-box {
  position: absolute;
  border: 2px dashed var(--primary-color);
  background: rgba(0, 242, 255, 0.15);
  box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.5);
  pointer-events: none;
  z-index: 10;
}

.selection-label {
  position: absolute;
  top: -24px;
  left: 0;
  background: var(--primary-color);
  color: black;
  font-size: 0.7rem;
  font-weight: bold;
  padding: 2px 6px;
  border-radius: 4px;
  white-space: nowrap;
  text-transform: uppercase;
}


.controls-panel {
  background: var(--surface-color);
  backdrop-filter: var(--glass-blur);
  border-left: 1px solid var(--border-color);
  padding: 2rem;
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
  overflow-y: auto;
  scrollbar-width: thin;
  scrollbar-color: var(--border-color) transparent;
}

.control-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 0.5rem;
  cursor: pointer;
}

.header-controls {
  display: flex;
  gap: 0.5rem;
  align-items: center;
}

.collapse-btn {
  background: transparent;
  border: none;
  color: var(--text-dim);
  cursor: pointer;
  padding: 4px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 4px;
}

.control-group.collapsed {
  margin-bottom: 0.5rem;
}

.control-group.collapsed h3 {
  opacity: 0.6;
}

.animate-toggle {
  background: var(--glass-bg);
  border: 1px solid var(--border-color);
  color: var(--text-dim);
  width: 24px;
  height: 24px;
  border-radius: 6px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.2s;
}

.animate-toggle:hover {
  border-color: var(--primary-color);
  color: var(--primary-color);
}

.animate-toggle.active {
  background: var(--primary-color);
  border-color: var(--primary-color);
  color: black;
  box-shadow: 0 0 10px var(--primary-color);
}

.animation-sliders {
  display: flex;
  flex-direction: column;
  gap: 1rem;
  padding-left: 0.5rem;
  border-left: 2px solid var(--border-color);
  margin-left: 0.25rem;
}

h3 {
  font-size: 0.9rem;
  text-transform: uppercase;
  color: var(--text-dim);
  letter-spacing: 0.1em;
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.control-group {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
}

.slider-container {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.slider-label {
  display: flex;
  justify-content: space-between;
  font-size: 0.85rem;
}

input[type="range"] {
  appearance: none;
  width: 100%;
  height: 4px;
  background: var(--border-color);
  border-radius: 2px;
  outline: none;
}

input[type="range"]::-webkit-slider-thumb {
  appearance: none;
  width: 12px;
  height: 12px;
  background: var(--primary-color);
  border-radius: 50%;
  cursor: pointer;
  box-shadow: 0 0 10px var(--primary-color);
  transition: transform 0.2s;
}

input[type="range"]::-webkit-slider-thumb:hover {
  transform: scale(1.3);
}

.preset-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 0.5rem;
}

.preset-button {
  background: var(--glass-bg);
  border: 1px solid var(--border-color);
  padding: 0.75rem;
  border-radius: 12px;
  color: white;
  font-size: 0.8rem;
  cursor: pointer;
  transition: all 0.2s;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.5rem;
}

.preset-button:hover {
  background: var(--border-color);
}

.preset-button.active {
  border-color: var(--primary-color);
  background: rgba(0, 242, 255, 0.1);
}

.action-button {
  background: linear-gradient(45deg, var(--accent-color), var(--secondary-color));
  border: none;
  padding: 1rem;
  border-radius: 12px;
  color: white;
  font-weight: 700;
  cursor: pointer;
  transition: transform 0.2s, box-shadow 0.2s;
  margin-top: 1rem;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.action-button:hover:not(:disabled) {
  transform: translateY(-2px);
  box-shadow: 0 10px 20px rgba(112, 0, 255, 0.3);
}

.action-button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.timeline-container {
  grid-column: 1 / -1;
  background: var(--surface-color);
  border: 1px solid var(--border-color);
  border-radius: 24px;
  padding: 1.5rem;
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.frame-strip {
  height: 60px;
  background: #111;
  border-radius: 8px;
  position: relative;
  display: flex;
  gap: 2px;
  overflow: hidden;
}

.range-handle {
  position: absolute;
  top: 0;
  bottom: 0;
  background: rgba(0, 242, 255, 0.2);
  border: 2px solid var(--primary-color);
  pointer-events: none;
}

@keyframes glitch {
  0% {
    transform: translate(0);
  }

  20% {
    transform: translate(-2px, 2px);
  }

  40% {
    transform: translate(-2px, -2px);
  }

  60% {
    transform: translate(2px, 2px);
  }

  80% {
    transform: translate(2px, -2px);
  }

  100% {
    transform: translate(0);
  }
}

.processing-overlay {
  position: absolute;
  inset: 0;
  background: rgba(0, 0, 0, 0.8);
  backdrop-filter: blur(4px);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 1.5rem;
  z-index: 10;
}

.loader {
  width: 48px;
  height: 48px;
  border: 3px solid var(--border-color);
  border-top-color: var(--primary-color);
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}

.timeline-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1rem;
}

.timeline-slider {
  position: relative;
  height: 20px;
  display: flex;
  align-items: center;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 10px;
  padding: 0 10px;
}

.timeline-slider::before {
  content: "";
  position: absolute;
  left: 10px;
  right: 10px;
  height: 4px;
  background: var(--border-color);
  border-radius: 2px;
}

.palette-preview {
  display: flex;
  flex-wrap: wrap;
  gap: 4px;
  margin-top: 1rem;
  padding: 8px;
  background: rgba(0, 0, 0, 0.3);
  border-radius: 8px;
  min-height: 40px;
}

.palette-swatch {
  width: 24px;
  height: 24px;
  border-radius: 4px;
  border: 1px solid rgba(255, 255, 255, 0.1);
}

.custom-palette-actions {
  display: flex;
  gap: 0.5rem;
  margin-top: 0.5rem;
  align-items: center;
}

.color-adder {
  display: flex;
  align-items: center;
  gap: 4px;
}

.color-adder input[type="color"] {
  width: 30px;
  height: 30px;
  border: none;
  background: none;
  cursor: pointer;
}

.timeline-slider input[type="range"] {
  -webkit-appearance: none;
  appearance: none;
  background: transparent;
  position: absolute;
  left: 10px;
  right: 10px;
  width: calc(100% - 20px);
  pointer-events: none;
}

.timeline-slider input[type="range"]::-webkit-slider-thumb {
  pointer-events: auto;
}

.status-dot {
  width: 8px;
  height: 8px;
  background: var(--primary-color);
  border-radius: 50%;
  box-shadow: 0 0 10px var(--primary-color);
}

.upload-prompt {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 1rem;
  text-align: center;
}

.upload-prompt h2 {
  font-weight: 800;
  font-size: 1.8rem;
}

.upload-prompt p {
  color: var(--text-dim);
}

.status-toast {
  position: fixed;
  bottom: 2rem;
  right: 2rem;
  padding: 1rem 1.5rem;
  background: var(--surface-color);
  border: 1px solid var(--primary-color);
  border-radius: 12px;
  z-index: 1000;
  display: flex;
  align-items: center;
  gap: 0.75rem;
  animation: slideIn 0.3s ease;
}

@keyframes slideIn {
  from {
    transform: translateX(100%);
    opacity: 0;
  }

  to {
    transform: translateX(0);
    opacity: 1;
  }
}

/* History Gallery */
.history-gallery {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  height: 160px;
  background: rgba(5, 5, 5, 0.95);
  backdrop-filter: blur(20px);
  border-top: 1px solid var(--border-color);
  padding: 1rem 1.5rem;
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
  z-index: 50;
  transform: translateY(0);
  transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
}

.history-gallery.hidden {
  transform: translateY(calc(100% - 40px));
}

.history-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.history-items {
  display: flex;
  gap: 1.5rem;
  overflow-x: auto;
  padding: 0.5rem 0;
  scrollbar-width: thin;
}

.history-item {
  width: 80px;
  height: 80px;
  border-radius: 12px;
  overflow: hidden;
  border: 2px solid var(--border-color);
  cursor: pointer;
  flex-shrink: 0;
  position: relative;
  transition: all 0.3s ease;
  background: black;
}

.history-item:hover {
  border-color: var(--primary-color);
  transform: translateY(-5px);
}

.history-item.active {
  border-color: var(--primary-color);
  box-shadow: 0 0 15px var(--primary-glow);
}

.history-item img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.history-item .item-time {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  background: rgba(0, 0, 0, 0.8);
  font-size: 10px;
  padding: 4px;
  text-align: center;
}

.gallery-toggle {
  position: absolute;
  top: -40px;
  right: 2rem;
  background: var(--surface-color);
  border: 1px solid var(--border-color);
  border-bottom: none;
  border-radius: 12px 12px 0 0;
  padding: 8px 16px;
  color: var(--text-dim);
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 0.8rem;
}

.gallery-toggle:hover {
  color: white;
}

/* Mobile Responsiveness */
@media (max-width: 768px) {
  .app-container {
    height: auto;
    min-height: 100vh;
    overflow-y: auto;
  }

  main {
    flex-direction: column;
    height: auto;
    overflow: visible;
  }

  .preview-area {
    height: auto;
    min-height: 350px;
    padding: 1rem;
    flex: none;
  }

  .sidebar-resizer {
    display: none;
  }

  .controls-panel {
    width: 100% !important;
    height: auto;
    border-left: none;
    border-top: 1px solid var(--border-color);
    padding: 1.5rem;
    overflow: visible;
  }

  .history-gallery {
    height: 140px;
  }

  .history-item {
    width: 70px;
    height: 70px;
  }

  .gallery-toggle {
    right: 1rem;
    padding: 6px 12px;
  }

  /* Touch enhancements */
  input[type="range"] {
    height: 10px;
  }

  input[type="range"]::-webkit-slider-thumb {
    width: 20px;
    height: 20px;
  }

  .preset-button,
  .action-button {
    padding: 1rem;
    min-height: 48px;
  }

  .control-header {
    padding: 8px 0;
  }

  .upload-zone {
    height: 300px;
  }
}
.app-footer {
  padding: 1rem 2rem;
  border-top: 1px solid var(--border-color);
  background: var(--surface-color);
  text-align: center;
  font-size: 0.8rem;
  color: var(--text-dim);
}

.app-footer a {
  color: var(--primary-color);
  text-decoration: none;
}

.app-footer a:hover {
  text-decoration: underline;
}

@media (max-width: 768px) {
  .app-footer {
    padding: 1.5rem;
    margin-bottom: 0;
  }
}
</file>

<file path="src/App.jsx">
import React, { useState, useRef, useEffect, useCallback } from 'react';
import { Upload, Download, Sliders, Layers, Monitor, Image as ImageIcon, Zap, Palette, Trash2, ArrowRight, Plus, X, Grid, Cpu, Activity, Tv, MoveHorizontal, Box } from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';
import gifFrames from 'gif-frames';
import GIF from 'gif.js';
import chroma from 'chroma-js';

// Pre-calculation of Bayer matrix for crispy dither
const bayerMatrix8x8 = [
  [0, 32, 8, 40, 2, 34, 10, 42],
  [48, 16, 56, 24, 50, 18, 58, 26],
  [12, 44, 4, 36, 14, 46, 6, 38],
  [60, 28, 52, 20, 62, 30, 54, 22],
  [3, 35, 11, 43, 1, 33, 9, 41],
  [51, 19, 59, 27, 49, 17, 57, 25],
  [15, 47, 7, 39, 13, 45, 5, 37],
  [63, 31, 55, 23, 61, 29, 53, 21]
];

const DITHER_ALGOS = {
  'Bayer': { type: 'ordered' },
  'Floyd-Steinberg': {
    type: 'diffusion',
    kernel: [
      { x: 1, y: 0, w: 7 / 16 },
      { x: -1, y: 1, w: 3 / 16 },
      { x: 0, y: 1, w: 5 / 16 },
      { x: 1, y: 1, w: 1 / 16 }
    ]
  },
  'Atkinson': {
    type: 'diffusion',
    kernel: [
      { x: 1, y: 0, w: 1 / 8 },
      { x: 2, y: 0, w: 1 / 8 },
      { x: -1, y: 1, w: 1 / 8 },
      { x: 0, y: 1, w: 1 / 8 },
      { x: 1, y: 1, w: 1 / 8 },
      { x: 0, y: 2, w: 1 / 8 }
    ]
  },
  'Sierra Lite': {
    type: 'diffusion',
    kernel: [
      { x: 1, y: 0, w: 2 / 4 },
      { x: -1, y: 1, w: 1 / 4 },
      { x: 0, y: 1, w: 1 / 4 }
    ]
  }
};

const PRESET_PALETTES = {
  'True Color': null,
  'Gameboy': ['#0f380f', '#306230', '#8bac0f', '#9bbc0f'],
  'CGA': ['#000000', '#55FFFF', '#FF55FF', '#FFFFFF'],
  'NES': ['#000000', '#fc9838', '#80d010', '#38b4f8', '#d8f878', '#fc44ce', '#f8d878', '#ffffff'],
  'C64': ['#000000', '#FFFFFF', '#880000', '#AAFFEE', '#CC44CC', '#00CC55', '#0000AA', '#EEEE77', '#DD8855', '#664400', '#FF7777', '#333333', '#777777', '#AAFF66', '#0088FF', '#BBBBBB'],
  'Cyber': ['#050505', '#00f2ff', '#ff00ea', '#7000ff']
};

export default function App() {
  const [originalGif, setOriginalGif] = useState(null);
  const [frames, setFrames] = useState([]);
  const [isProcessing, setIsProcessing] = useState(false);
  const [outputGif, setOutputGif] = useState(null);
  const [progress, setProgress] = useState(0);

  // Core Controls
  const [retro, setRetro] = useState({ start: 50, end: 50, animate: false });
  const [glitch, setGlitch] = useState({ start: 0, end: 100, animate: false });
  const [painterly, setPainterly] = useState({ start: 0, end: 100, animate: false });
  const [crt, setCrt] = useState({ start: 30, end: 30, animate: false });
  const [glow, setGlow] = useState({ start: 0, end: 50, animate: false });
  const [pixelSort, setPixelSort] = useState({ start: 0, end: 100, animate: false, threshold: 50 });
  const [downscale, setDownscale] = useState(1);

  const [frameRange, setFrameRange] = useState([0, 100]);
  const [falloff, setFalloff] = useState(20);
  const [status, setStatus] = useState('');
  const [ditherAlgo, setDitherAlgo] = useState('Bayer');
  const [compareSplit, setCompareSplit] = useState(50);
  const [showComparison, setShowComparison] = useState(false);
  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });
  const [isDragging, setIsDragging] = useState(false);

  // Selection Tool State
  const [useSelection, setUseSelection] = useState(false);
  const [selection, setSelection] = useState({ x: 10, y: 10, w: 80, h: 80 });
  const [isResizingSelection, setIsResizingSelection] = useState(false);
  const [selectionStart, setSelectionStart] = useState({ x: 0, y: 0 });

  // History & Persistence State
  const [history, setHistory] = useState([]);
  const [sidebarWidth, setSidebarWidth] = useState(380);
  const [collapsedGroups, setCollapsedGroups] = useState({});
  const [isResizingSidebar, setIsResizingSidebar] = useState(false);
  const [showHistory, setShowHistory] = useState(true);
  const [isMobile, setIsMobile] = useState(window.innerWidth < 768);

  // Handle Resize for Mobile Check
  useEffect(() => {
    const handleResize = () => setIsMobile(window.innerWidth < 768);
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  // Palette State
  const [selectedPaletteName, setSelectedPaletteName] = useState('True Color');
  const [customPalette, setCustomPalette] = useState([]);
  const [isAutoClustering, setIsAutoClustering] = useState(false);

  const fileInputRef = useRef(null);
  const comparisonRef = useRef(null);
  const previewImageRef = useRef(null);
  const previewWrapperRef = useRef(null);

  // Helper: Get the actual rendered bounds of the image within its container
  const getImageBounds = useCallback(() => {
    const img = previewImageRef.current;
    const wrapper = previewWrapperRef.current;
    if (!img || !wrapper) return null;

    const wrapperRect = wrapper.getBoundingClientRect();
    const imgNaturalWidth = dimensions.width || img.naturalWidth;
    const imgNaturalHeight = dimensions.height || img.naturalHeight;

    if (!imgNaturalWidth || !imgNaturalHeight) return null;

    // Calculate how the image is rendered with object-fit: contain
    const wrapperAspect = wrapperRect.width / wrapperRect.height;
    const imgAspect = imgNaturalWidth / imgNaturalHeight;

    let renderedWidth, renderedHeight, offsetX, offsetY;

    if (imgAspect > wrapperAspect) {
      // Image is wider - letterbox top/bottom
      renderedWidth = wrapperRect.width;
      renderedHeight = wrapperRect.width / imgAspect;
      offsetX = 0;
      offsetY = (wrapperRect.height - renderedHeight) / 2;
    } else {
      // Image is taller - letterbox left/right
      renderedHeight = wrapperRect.height;
      renderedWidth = wrapperRect.height * imgAspect;
      offsetX = (wrapperRect.width - renderedWidth) / 2;
      offsetY = 0;
    }

    return {
      wrapperRect,
      offsetX,
      offsetY,
      renderedWidth,
      renderedHeight
    };
  }, [dimensions]);

  // Convert client coordinates to image percentage coordinates
  const clientToImagePercent = useCallback((clientX, clientY) => {
    const bounds = getImageBounds();
    if (!bounds) return { x: 0, y: 0, inBounds: false };

    const { wrapperRect, offsetX, offsetY, renderedWidth, renderedHeight } = bounds;

    // Position relative to wrapper
    const relX = clientX - wrapperRect.left;
    const relY = clientY - wrapperRect.top;

    // Position relative to the actual image area
    const imgX = relX - offsetX;
    const imgY = relY - offsetY;

    // Check if within image bounds
    const inBounds = imgX >= 0 && imgX <= renderedWidth && imgY >= 0 && imgY <= renderedHeight;

    // Convert to percentage (clamped to 0-100)
    const percentX = Math.max(0, Math.min(100, (imgX / renderedWidth) * 100));
    const percentY = Math.max(0, Math.min(100, (imgY / renderedHeight) * 100));

    return { x: percentX, y: percentY, inBounds };
  }, [getImageBounds]);

  // Hydrate from localStorage
  useEffect(() => {
    const saved = localStorage.getItem('dither-lab-settings');
    if (saved) {
      try {
        const settings = JSON.parse(saved);
        if (settings.retro) setRetro(settings.retro);
        if (settings.glitch) setGlitch(settings.glitch);
        if (settings.painterly) setPainterly(settings.painterly);
        if (settings.crt) setCrt(settings.crt);
        if (settings.glow) setGlow(settings.glow);
        if (settings.pixelSort) setPixelSort(settings.pixelSort);
        if (settings.downscale) setDownscale(settings.downscale);
        if (settings.selectedPaletteName) setSelectedPaletteName(settings.selectedPaletteName);
        if (settings.customPalette) setCustomPalette(settings.customPalette);
        if (settings.ditherAlgo) setDitherAlgo(settings.ditherAlgo);
        if (settings.sidebarWidth) setSidebarWidth(settings.sidebarWidth);
        if (settings.collapsedGroups) setCollapsedGroups(settings.collapsedGroups);
      } catch (e) {
        console.error("Failed to hydrate settings", e);
      }
    }
  }, []);

  // Save to localStorage
  useEffect(() => {
    const settings = {
      retro, glitch, painterly, crt, glow, pixelSort, downscale,
      selectedPaletteName, customPalette, ditherAlgo, sidebarWidth, collapsedGroups
    };
    localStorage.setItem('dither-lab-settings', JSON.stringify(settings));
  }, [retro, glitch, painterly, crt, glow, pixelSort, downscale, selectedPaletteName, customPalette, ditherAlgo, sidebarWidth, collapsedGroups]);

  // Resizable Sidebar Handling
  const startResizing = useCallback((e) => {
    e.preventDefault();
    setIsResizingSidebar(true);
  }, []);

  const stopResizing = useCallback(() => {
    setIsResizingSidebar(false);
  }, []);

  const resize = useCallback((e) => {
    if (isResizingSidebar && !isMobile) {
      const newWidth = window.innerWidth - e.clientX;
      if (newWidth > 250 && newWidth < 800) {
        setSidebarWidth(newWidth);
      }
    }
  }, [isResizingSidebar, isMobile]);

  useEffect(() => {
    if (isResizingSidebar) {
      window.addEventListener('mousemove', resize);
      window.addEventListener('mouseup', stopResizing);
    }
    return () => {
      window.removeEventListener('mousemove', resize);
      window.removeEventListener('mouseup', stopResizing);
    };
  }, [isResizingSidebar, resize, stopResizing]);

  // Comparison slider mouse/touch handling
  const handleSliderInteraction = useCallback((clientX) => {
    if (!comparisonRef.current) return;
    const rect = comparisonRef.current.getBoundingClientRect();
    const x = clientX - rect.left;
    const percentage = Math.max(0, Math.min(100, (x / rect.width) * 100));
    setCompareSplit(percentage);
  }, []);

  const handleMouseDown = useCallback((e) => {
    e.preventDefault();
    setIsDragging(true);
    handleSliderInteraction(e.clientX);
  }, [handleSliderInteraction]);

  const handleMouseMove = useCallback((e) => {
    if (!isDragging) return;
    handleSliderInteraction(e.clientX);
  }, [isDragging, handleSliderInteraction]);

  const handleMouseUp = useCallback(() => {
    setIsDragging(false);
  }, []);

  const handleTouchStart = useCallback((e) => {
    e.preventDefault();
    setIsDragging(true);
    handleSliderInteraction(e.touches[0].clientX);
  }, [handleSliderInteraction]);

  const handleTouchMove = useCallback((e) => {
    if (!isDragging) return;
    handleSliderInteraction(e.touches[0].clientX);
  }, [isDragging, handleSliderInteraction]);

  // Selection mouse handling - now using image-relative coordinates
  const handleSelectionStart = useCallback((e) => {
    if (!useSelection || showComparison) return;

    const { x, y, inBounds } = clientToImagePercent(e.clientX, e.clientY);
    if (!inBounds) return;

    setSelectionStart({ x, y });
    setIsResizingSelection(true);
    setSelection({ x, y, w: 0, h: 0 });
  }, [useSelection, showComparison, clientToImagePercent]);

  const handleSelectionMove = useCallback((e) => {
    if (!isResizingSelection) return;

    const { x, y } = clientToImagePercent(e.clientX, e.clientY);

    setSelection({
      x: Math.min(x, selectionStart.x),
      y: Math.min(y, selectionStart.y),
      w: Math.abs(x - selectionStart.x),
      h: Math.abs(y - selectionStart.y)
    });
  }, [isResizingSelection, selectionStart, clientToImagePercent]);

  const handleSelectionEnd = useCallback(() => {
    setIsResizingSelection(false);
  }, []);

  // Add global mouse/touch listeners when dragging
  useEffect(() => {
    if (isDragging) {
      window.addEventListener('mousemove', handleMouseMove);
      window.addEventListener('mouseup', handleMouseUp);
      window.addEventListener('touchmove', handleTouchMove);
      window.addEventListener('touchend', handleMouseUp);
    }
    return () => {
      window.removeEventListener('mousemove', handleMouseMove);
      window.removeEventListener('mouseup', handleMouseUp);
      window.removeEventListener('touchmove', handleTouchMove);
      window.removeEventListener('touchend', handleMouseUp);
    };
  }, [isDragging, handleMouseMove, handleMouseUp, handleTouchMove]);

  // Global listeners for selection dragging
  useEffect(() => {
    if (isResizingSelection) {
      const moveHandler = (e) => handleSelectionMove(e);
      window.addEventListener('mousemove', moveHandler);
      window.addEventListener('mouseup', handleSelectionEnd);
      return () => {
        window.removeEventListener('mousemove', moveHandler);
        window.removeEventListener('mouseup', handleSelectionEnd);
      };
    }
  }, [isResizingSelection, handleSelectionMove, handleSelectionEnd]);

  const handleFileUpload = async (e) => {
    const file = e.target.files[0];
    if (!file) return;
    setStatus('Loading frames...');
    setIsProcessing(true);
    try {
      const url = URL.createObjectURL(file);
      setOriginalGif(url);
      const frameData = await gifFrames({ url, frames: 'all', outputType: 'canvas', cumulative: true });
      const extractedFrames = frameData.map(f => f.getImage());
      const first = extractedFrames[0];
      setDimensions({ width: first.width, height: first.height });
      setFrames(extractedFrames);
      setFrameRange([0, extractedFrames.length - 1]);
      setStatus('GIF loaded.');
    } catch (err) {
      console.error(err);
      setStatus('Error loading GIF');
    } finally {
      setIsProcessing(false);
    }
  };

  const getNearestColor = (r, g, b, cachedPalette) => {
    let minDistance = Infinity;
    let closestR = r, closestG = g, closestB = b;
    for (let i = 0; i < cachedPalette.length; i++) {
      const p = cachedPalette[i];
      const dr = r - p[0], dg = g - p[1], db = b - p[2];
      const dist = dr * dr + dg * dg + db * db;
      if (dist < minDistance) {
        minDistance = dist;
        closestR = p[0]; closestG = p[1]; closestB = p[2];
      }
    }
    return [closestR, closestG, closestB];
  };

  const runKMeans = () => {
    if (frames.length === 0) return;
    setIsAutoClustering(true);
    setStatus('Analyzing colors...');
    setTimeout(() => {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const firstFrame = frames[0];
      canvas.width = firstFrame.width; canvas.height = firstFrame.height;
      ctx.drawImage(firstFrame, 0, 0);
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      const samples = [];
      const step = Math.floor(data.length / 4000) * 4;
      for (let i = 0; i < data.length; i += step) {
        samples.push([data[i], data[i + 1], data[i + 2]]);
      }
      let centroids = samples.slice(0, 8);
      for (let iter = 0; iter < 5; iter++) {
        const clusters = Array.from({ length: 8 }, () => []);
        for (const s of samples) {
          let bestDist = Infinity, bestIdx = 0;
          for (let i = 0; i < centroids.length; i++) {
            const d = Math.pow(s[0] - centroids[i][0], 2) + Math.pow(s[1] - centroids[i][1], 2) + Math.pow(s[2] - centroids[i][2], 2);
            if (d < bestDist) { bestDist = d; bestIdx = i; }
          }
          clusters[bestIdx].push(s);
        }
        centroids = clusters.map(c => {
          if (c.length === 0) return [Math.random() * 255, Math.random() * 255, Math.random() * 255];
          const sum = c.reduce((acc, val) => [acc[0] + val[0], acc[1] + val[1], acc[2] + val[2]], [0, 0, 0]);
          return [sum[0] / c.length, sum[1] / c.length, sum[2] / c.length];
        });
      }
      setCustomPalette(centroids.map(c => chroma(c).hex()));
      setSelectedPaletteName('Custom');
      setIsAutoClustering(false);
      setStatus('Palette generated!');
    }, 100);
  };

  const lerp = (v0, v1, t) => v0 * (1 - t) + v1 * t;

  const performPixelSort = (canvas, amount, threshold, isInSelection) => {
    const ctx = canvas.getContext('2d');
    const { width, height } = canvas;
    const imageData = ctx.getImageData(0, 0, width, height);
    const data = imageData.data;

    // Simple vertical pixel sort
    for (let x = 0; x < width; x++) {
      let column = [];
      for (let y = 0; y < height; y++) {
        const i = (y * width + x) * 4;
        const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
        column.push({ r: data[i], g: data[i + 1], b: data[i + 2], a: data[i + 3], bness: brightness, inSel: isInSelection(x, y, width, height) });
      }

      // Sort segments based on threshold - only within selection
      let start = 0;
      while (start < height) {
        let end = start;
        while (end < height && column[end].bness > (threshold / 100) * 255 && column[end].inSel) end++;

        if (end > start && Math.random() < amount / 100) {
          const segment = column.slice(start, end).sort((a, b) => a.bness - b.bness);
          for (let y = 0; y < segment.length; y++) {
            const i = ((start + y) * width + x) * 4;
            data[i] = segment[y].r;
            data[i + 1] = segment[y].g;
            data[i + 2] = segment[y].b;
            data[i + 3] = segment[y].a;
          }
        }
        start = end + 1;
      }
    }
    ctx.putImageData(imageData, 0, 0);
  };

  const processGif = async () => {
    if (frames.length === 0) return;
    setIsProcessing(true);
    setProgress(0);
    setStatus('Preparing Palette...');

    const rawPalette = selectedPaletteName === 'Custom' ? customPalette : PRESET_PALETTES[selectedPaletteName];
    const cachedPalette = rawPalette ? rawPalette.map(c => chroma(c).rgb()) : null;

    // Downscale targets
    const baseWidth = frames[0].width;
    const baseHeight = frames[0].height;
    const workWidth = Math.floor(baseWidth / downscale);
    const workHeight = Math.floor(baseHeight / downscale);

    const gif = new GIF({
      workers: 4, quality: 10,
      width: baseWidth, height: baseHeight,
      workerScript: '/gif.worker.js'
    });

    const start = frameRange[0];
    const end = frameRange[1];
    const totalSelected = end - start + 1;

    // Precompute selection bounds in pixels (for current working dimensions)
    // Selection is stored as percentages of the image
    const getSelectionBounds = (w, h) => {
      if (!useSelection || selection.w === 0 || selection.h === 0) {
        return { sx: 0, sy: 0, sw: w, sh: h, enabled: false };
      }
      return {
        sx: Math.floor((selection.x / 100) * w),
        sy: Math.floor((selection.y / 100) * h),
        sw: Math.floor((selection.w / 100) * w),
        sh: Math.floor((selection.h / 100) * h),
        enabled: true
      };
    };

    for (let index = 0; index < frames.length; index++) {
      const originalFrame = frames[index];
      const canvas = document.createElement('canvas');
      canvas.width = baseWidth;
      canvas.height = baseHeight;
      const ctx = canvas.getContext('2d');

      // Draw original frame
      ctx.drawImage(originalFrame, 0, 0, baseWidth, baseHeight);

      let t = 0;
      if (index >= start && index <= end) {
        t = 1;
        const distFromStart = index - start, distFromEnd = end - index;
        const falloffFrames = Math.floor((falloff / 100) * totalSelected) || 1;
        if (distFromStart < falloffFrames) t = distFromStart / falloffFrames;
        if (distFromEnd < falloffFrames) t = Math.min(t, distFromEnd / falloffFrames);
      }

      // Check if pixel is in selection
      const isInSelection = (px, py, w, h) => {
        if (!useSelection || selection.w === 0 || selection.h === 0) return true;
        const sx = (selection.x / 100) * w;
        const sy = (selection.y / 100) * h;
        const sw = (selection.w / 100) * w;
        const sh = (selection.h / 100) * h;
        return px >= sx && px < sx + sw && py >= sy && py < sy + sh;
      };

      if (t > 0) {
        const animProgress = (index - start) / totalSelected;
        const currentRetro = retro.animate ? lerp(retro.start, retro.end, animProgress) : retro.start;
        const currentGlitch = glitch.animate ? lerp(glitch.start, glitch.end, animProgress) : glitch.start;
        const currentPainterly = painterly.animate ? lerp(painterly.start, painterly.end, animProgress) : painterly.start;
        const currentCRT = crt.animate ? lerp(crt.start, crt.end, animProgress) : crt.start;
        const currentGlow = glow.animate ? lerp(glow.start, glow.end, animProgress) : glow.start;
        const currentSort = pixelSort.animate ? lerp(pixelSort.start, pixelSort.end, animProgress) : pixelSort.start;

        // 1. Resolution Downscale (Internal resampling)
        if (downscale > 1) {
          const offCanvas = document.createElement('canvas');
          offCanvas.width = workWidth; offCanvas.height = workHeight;
          const offCtx = offCanvas.getContext('2d');
          offCtx.imageSmoothingEnabled = false;
          offCtx.drawImage(canvas, 0, 0, workWidth, workHeight);

          canvas.width = workWidth; canvas.height = workHeight;
          ctx.imageSmoothingEnabled = false;
          ctx.drawImage(offCanvas, 0, 0);
        }

        const width = canvas.width;
        const height = canvas.height;
        const imageData = ctx.getImageData(0, 0, width, height);
        const data = imageData.data;

        // Store original data for non-selected pixels
        const originalData = new Uint8ClampedArray(data);

        const strength = (currentRetro / 100) * t;
        const pStep = Math.floor(currentPainterly / 10) + 1;
        const algo = DITHER_ALGOS[ditherAlgo];

        // Dithering loop
        if (algo.type === 'diffusion') {
          const errorBuffer = new Float32Array(data.length);
          for (let i = 0; i < data.length; i++) errorBuffer[i] = data[i];

          for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
              const i = (y * width + x) * 4;
              let r = errorBuffer[i], g = errorBuffer[i + 1], b = errorBuffer[i + 2];

              if (isInSelection(x, y, width, height)) {
                if (currentPainterly > 0) {
                  r = Math.round(r / (pStep * 20)) * (pStep * 20);
                  g = Math.round(g / (pStep * 20)) * (pStep * 20);
                  b = Math.round(b / (pStep * 20)) * (pStep * 20);
                }

                let [nr, ng, nb] = cachedPalette ? getNearestColor(r, g, b, cachedPalette) : [r > 127 ? 255 : 0, g > 127 ? 255 : 0, b > 127 ? 255 : 0];

                const blendR = r + (nr - r) * strength, blendG = g + (ng - g) * strength, blendB = b + (nb - b) * strength;
                data[i] = blendR; data[i + 1] = blendG; data[i + 2] = blendB;

                const er = r - blendR, eg = g - blendG, eb = b - blendB;
                for (const k of algo.kernel) {
                  const nx = x + k.x, ny = y + k.y;
                  if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                    const ni = (ny * width + nx) * 4;
                    errorBuffer[ni] += er * k.w; errorBuffer[ni + 1] += eg * k.w; errorBuffer[ni + 2] += eb * k.w;
                  }
                }

                if (currentGlitch > 0 && Math.random() < (currentGlitch / 5000) * t) data[i] = data[i + 20] || data[i];
                if (currentCRT > 0 && y % 2 === 0) { const s = 1 - (currentCRT / 150) * t; data[i] *= s; data[i + 1] *= s; data[i + 2] *= s; }
              } else {
                // Keep original pixel data for non-selected areas
                data[i] = originalData[i];
                data[i + 1] = originalData[i + 1];
                data[i + 2] = originalData[i + 2];
              }
            }
          }
        } else {
          for (let i = 0; i < data.length; i += 4) {
            const x = (i / 4) % width, y = Math.floor((i / 4) / width);

            if (isInSelection(x, y, width, height)) {
              let r = data[i], g = data[i + 1], b = data[i + 2];

              if (currentPainterly > 0) {
                r = Math.round(r / (pStep * 20)) * (pStep * 20);
                g = Math.round(g / (pStep * 20)) * (pStep * 20);
                b = Math.round(b / (pStep * 20)) * (pStep * 20);
              }
              if (currentRetro > 0) {
                const threshold = bayerMatrix8x8[y % 8][x % 8] / 64 * 255;
                const dr = r > threshold ? 255 : 0, dg = g > threshold ? 255 : 0, db = b > threshold ? 255 : 0;
                r = r + (dr - r) * strength; g = g + (dg - g) * strength; b = b + (db - b) * strength;
              }
              if (cachedPalette) { const [nr, ng, nb] = getNearestColor(r, g, b, cachedPalette); r = nr; g = ng; b = nb; }
              if (currentGlitch > 0 && Math.random() < (currentGlitch / 5000) * t) r = data[i + 20] || r;
              if (currentCRT > 0 && y % 2 === 0) { const s = 1 - (currentCRT / 150) * t; r *= s; g *= s; b *= s; }
              data[i] = r; data[i + 1] = g; data[i + 2] = b;
            }
            // Non-selected pixels already have original data, no need to change
          }
        }
        ctx.putImageData(imageData, 0, 0);

        // 2. Pixel Sort (with selection awareness)
        if (currentSort > 0) {
          performPixelSort(canvas, currentSort, pixelSort.threshold, isInSelection);
        }

        // 3. Glow (Bloom) - only apply to selected region
        if (currentGlow > 0) {
          const glowCanvas = document.createElement('canvas');
          glowCanvas.width = width; glowCanvas.height = height;
          const glowCtx = glowCanvas.getContext('2d');

          // If selection is enabled, mask the glow to the selection area
          if (useSelection && selection.w > 0 && selection.h > 0) {
            const selBounds = getSelectionBounds(width, height);
            glowCtx.filter = `blur(${Math.max(1, currentGlow / 10)}px)`;
            glowCtx.drawImage(canvas, selBounds.sx, selBounds.sy, selBounds.sw, selBounds.sh,
              selBounds.sx, selBounds.sy, selBounds.sw, selBounds.sh);

            // Create a mask for the selection area
            ctx.save();
            ctx.beginPath();
            ctx.rect(selBounds.sx, selBounds.sy, selBounds.sw, selBounds.sh);
            ctx.clip();
            ctx.globalAlpha = (currentGlow / 150) * t;
            ctx.globalCompositeOperation = 'screen';
            ctx.drawImage(glowCanvas, 0, 0);
            ctx.restore();
          } else {
            glowCtx.filter = `blur(${Math.max(1, currentGlow / 10)}px)`;
            glowCtx.drawImage(canvas, 0, 0);
            ctx.globalAlpha = (currentGlow / 150) * t;
            ctx.globalCompositeOperation = 'screen';
            ctx.drawImage(glowCanvas, 0, 0);
          }
          ctx.globalAlpha = 1.0; ctx.globalCompositeOperation = 'source-over';
        }

        // 4. Upscale back to original size if downscaled
        if (downscale > 1) {
          const tempCanvas = document.createElement('canvas');
          tempCanvas.width = baseWidth; tempCanvas.height = baseHeight;
          const tempCtx = tempCanvas.getContext('2d');
          tempCtx.imageSmoothingEnabled = false;
          tempCtx.drawImage(canvas, 0, 0, baseWidth, baseHeight);
          canvas.width = baseWidth; canvas.height = baseHeight;
          ctx.imageSmoothingEnabled = false;
          ctx.drawImage(tempCanvas, 0, 0);
        }
      }

      gif.addFrame(canvas, { delay: 100, copy: true });
      setProgress(Math.round(((index + 1) / frames.length) * 50));
      setStatus(`Processing: ${index + 1}/${frames.length}`);
      if (index % 5 === 0) await new Promise(r => setTimeout(r, 0));
    }
    gif.on('progress', p => { setProgress(50 + Math.round(p * 50)); setStatus(`Rendering: ${Math.round(p * 100)}%`); });
    gif.on('finished', blob => {
      const url = URL.createObjectURL(blob);
      setOutputGif(url);
      setIsProcessing(false);
      setStatus('Done!');
      setShowComparison(true);

      // Add to history
      setHistory(prev => [{
        id: Date.now(),
        url,
        timestamp: new Date().toLocaleTimeString(),
        settings: { ditherAlgo, palette: selectedPaletteName, retro: retro.start }
      }, ...prev].slice(0, 10)); // Keep last 10
    });
    gif.render();
  };

  const ControlSlider = ({ title, value, onChange, icon: Icon, extra, id }) => {
    const isCollapsed = collapsedGroups[id];
    return (
      <div className={`control-group ${isCollapsed ? 'collapsed' : ''}`}>
        <div className="control-header" onClick={() => id && setCollapsedGroups(prev => ({ ...prev, [id]: !prev[id] }))} style={{ cursor: id ? 'pointer' : 'default' }}>
          <h3><Icon size={14} /> {title}</h3>
          <div className="header-controls">
            {onChange && (
              <button className={`animate-toggle ${value.animate ? 'active' : ''}`} onClick={(e) => { e.stopPropagation(); onChange({ ...value, animate: !value.animate }); }}><Activity size={12} /></button>
            )}
            {id && <button className="collapse-btn">{isCollapsed ? <Plus size={12} /> : <X size={12} />}</button>}
          </div>
        </div>
        {!isCollapsed && (
          <>
            {onChange && (!value.animate ? (
              <div className="slider-container">
                <div className="slider-label"><span>Static</span><span>{Math.round(value.start)}%</span></div>
                <input type="range" value={value.start} onChange={(e) => onChange({ ...value, start: parseInt(e.target.value), end: parseInt(e.target.value) })} />
              </div>
            ) : (
              <div className="animation-sliders">
                <div className="slider-container">
                  <div className="slider-label"><span>Start</span><span>{Math.round(value.start)}%</span></div>
                  <input type="range" value={value.start} onChange={(e) => onChange({ ...value, start: parseInt(e.target.value) })} />
                </div>
                <div className="slider-container">
                  <div className="slider-label"><span>End</span><span>{Math.round(value.end)}%</span></div>
                  <input type="range" value={value.end} onChange={(e) => onChange({ ...value, end: parseInt(e.target.value) })} />
                </div>
              </div>
            ))}
            {extra}
          </>
        )}
      </div>
    );
  };

  // Calculate selection box position relative to the actual image for display
  const getSelectionStyle = useCallback(() => {
    const bounds = getImageBounds();
    if (!bounds || !useSelection) return { display: 'none' };

    const { offsetX, offsetY, renderedWidth, renderedHeight } = bounds;

    return {
      left: `${offsetX + (selection.x / 100) * renderedWidth}px`,
      top: `${offsetY + (selection.y / 100) * renderedHeight}px`,
      width: `${(selection.w / 100) * renderedWidth}px`,
      height: `${(selection.h / 100) * renderedHeight}px`,
    };
  }, [getImageBounds, useSelection, selection]);

  return (
    <div className="app-container">
      <header>
        <div className="header-brand">
          <div className="logo">GIF DITHER LAB</div>
          <div className="instructions">
            <span>1. Upload GIF</span>
            <ArrowRight size={10} />
            <span>2. Tweak Effects</span>
            <ArrowRight size={10} />
            <span>3. Mask Region</span>
            <ArrowRight size={10} />
            <span>4. Export</span>
          </div>
        </div>
        <div className="header-actions">
          {originalGif && (
            <button className="preset-button" onClick={() => { setOriginalGif(null); setFrames([]); setOutputGif(null); setCustomPalette([]); setShowComparison(false); }}><Trash2 size={16} /> Reset</button>
          )}
        </div>
      </header>
      <main>
        <section className="preview-area">
          <div className={`upload-zone ${!originalGif ? 'empty' : ''}`} onClick={() => !originalGif && fileInputRef.current.click()}>
            <input type="file" ref={fileInputRef} hidden accept="image/gif" onChange={handleFileUpload} />
            {!originalGif ? (
              <div className="upload-prompt">
                <motion.div animate={{ y: [0, -10, 0] }} transition={{ repeat: Infinity, duration: 2 }}><Upload size={48} color="var(--primary-color)" /></motion.div>
                <h2>Drop your GIF here</h2>
                <p>or click to browse</p>
              </div>
            ) : (
              <div className="preview-container">
                {outputGif && showComparison ? (
                  <div
                    ref={comparisonRef}
                    className="comparison-slider"
                    style={{
                      '--split': `${compareSplit}%`,
                      aspectRatio: `${dimensions.width} / ${dimensions.height}`,
                      maxWidth: '100%',
                      maxHeight: '100%',
                      cursor: 'ew-resize'
                    }}
                    onMouseDown={handleMouseDown}
                    onTouchStart={handleTouchStart}
                  >
                    <img src={originalGif} className="compare-original" alt="Original" draggable={false} />
                    <img src={outputGif} className="compare-output" alt="Result" draggable={false} />
                    <div className="compare-handle" style={{ left: `${compareSplit}%` }}>
                      <div className="handle-line"></div>
                      <div className="handle-circle">
                        <MoveHorizontal size={16} />
                      </div>
                    </div>
                  </div>
                ) : (
                  <div
                    ref={previewWrapperRef}
                    className="preview-wrapper"
                    onMouseDown={handleSelectionStart}
                    style={{ cursor: useSelection ? 'crosshair' : 'default' }}
                  >
                    <img
                      ref={previewImageRef}
                      src={outputGif || originalGif}
                      alt="Preview"
                      draggable={false}
                      style={{ maxWidth: '100%', maxHeight: '100%', objectFit: 'contain' }}
                    />
                    {useSelection && !outputGif && selection.w > 0 && selection.h > 0 && (
                      <div
                        className="selection-box"
                        style={getSelectionStyle()}
                      >
                        <div className="selection-label">Target Region ({Math.round(selection.w)}%  {Math.round(selection.h)}%)</div>
                      </div>
                    )}
                  </div>
                )}

                {/* History Gallery Overlay */}
                {history.length > 0 && (
                  <div className={`history-gallery ${!showHistory ? 'hidden' : ''}`}>
                    <button className="gallery-toggle" onClick={() => setShowHistory(!showHistory)}>
                      {showHistory ? <X size={14} /> : <ImageIcon size={14} />} {showHistory ? 'Hide History' : 'Show History'}
                    </button>
                    <div className="history-header">
                      <h3><Activity size={14} /> Session History</h3>
                      <span style={{ fontSize: '0.7rem', color: 'var(--text-dim)' }}>{history.length} versions</span>
                    </div>
                    <div className="history-items">
                      {history.map(item => (
                        <div
                          key={item.id}
                          className={`history-item ${outputGif === item.url ? 'active' : ''}`}
                          onClick={() => { setOutputGif(item.url); setShowComparison(true); }}
                        >
                          <img src={item.url} alt="History version" />
                          <div className="item-time">{item.timestamp}</div>
                        </div>
                      ))}
                    </div>
                  </div>
                )}

                {isProcessing && <div className="processing-overlay"><div className="loader"></div><p>{status} {progress}%</p></div>}
              </div>
            )}
          </div>
          {frames.length > 0 && (
            <div className="timeline-container">
              <div className="timeline-header">
                <h3><Layers size={14} /> Dither Range: {frameRange[0]} - {frameRange[1]}</h3>
                <div className="timeline-controls"><span>Falloff: {falloff}%</span><input type="range" value={falloff} onChange={(e) => setFalloff(parseInt(e.target.value))} style={{ width: '80px' }} /></div>
              </div>
              <div className="timeline-slider">
                <input type="range" min="0" max={frames.length - 1} value={frameRange[0]} onChange={(e) => setFrameRange([Math.min(parseInt(e.target.value), frameRange[1]), frameRange[1]])} />
                <input type="range" min="0" max={frames.length - 1} value={frameRange[1]} onChange={(e) => setFrameRange([frameRange[0], Math.max(parseInt(e.target.value), frameRange[0])])} />
              </div>
            </div>
          )}
        </section>

        <div className={`sidebar-resizer ${isResizingSidebar ? 'active' : ''}`} onMouseDown={startResizing} />

        <aside className="controls-panel" style={{ width: isMobile ? '100%' : `${sidebarWidth}px` }}>
          <div className="control-group">
            <h3><Palette size={14} /> Color Library</h3>
            <div className="preset-grid">
              {Object.keys(PRESET_PALETTES).map(name => (
                <button key={name} className={`preset-button ${selectedPaletteName === name ? 'active' : ''}`} onClick={() => setSelectedPaletteName(name)}>{name}</button>
              ))}
              <button className={`preset-button ${selectedPaletteName === 'Custom' ? 'active' : ''}`} onClick={() => setSelectedPaletteName('Custom')}>Custom</button>
            </div>
            <div className="palette-preview">{(selectedPaletteName === 'Custom' ? customPalette : PRESET_PALETTES[selectedPaletteName])?.map((c, i) => <div key={i} className="palette-swatch" style={{ background: c }}></div>)}</div>
            {selectedPaletteName === 'Custom' && (
              <div className="custom-palette-actions">
                <button className="preset-button" onClick={runKMeans} disabled={isAutoClustering}>{isAutoClustering ? 'Analyzing...' : 'Auto-Extract'}</button>
                <div className="color-adder"><input type="color" onChange={(e) => setCustomPalette([...customPalette, e.target.value])} title="Add Color" /><button className="preset-button" onClick={() => setCustomPalette([])}><Plus size={14} /></button></div>
              </div>
            )}
          </div>
          <div className="control-group">
            <h3><Grid size={14} /> Dither Algorithm</h3>
            <div className="preset-grid">{Object.keys(DITHER_ALGOS).map(algo => <button key={algo} className={`preset-button ${ditherAlgo === algo ? 'active' : ''}`} onClick={() => setDitherAlgo(algo)}>{algo}</button>)}</div>
          </div>

          <div className="control-group">
            <div className="control-header" onClick={() => setUseSelection(!useSelection)} style={{ cursor: 'pointer' }}>
              <h3><Layers size={14} /> Region Mask</h3>
              <button className={`animate-toggle ${useSelection ? 'active' : ''}`} onClick={(e) => { e.stopPropagation(); setUseSelection(!useSelection); setShowComparison(false); setOutputGif(null); }} title="Toggle Selection Tool">
                <Box size={14} />
              </button>
            </div>
            {useSelection && (
              <>
                <p style={{ fontSize: '0.8rem', color: 'var(--text-dim)', marginTop: '4px' }}>
                  Click and drag on the preview to select a region. Only this area will be dithered.
                </p>
                {selection.w > 0 && selection.h > 0 && (
                  <p style={{ fontSize: '0.75rem', color: 'var(--primary-color)', marginTop: '4px' }}>
                    Selection: {Math.round(selection.x)}%, {Math.round(selection.y)}%  {Math.round(selection.w)}%  {Math.round(selection.h)}%
                  </p>
                )}
              </>
            )}
          </div>

          <ControlSlider id="downscale" title="Downscale Factor" value={{ start: downscale }} onChange={null} icon={Box} extra={
            <div className="slider-container">
              <div className="slider-label"><span>Factor</span><span>{downscale}x</span></div>
              <input type="range" min="1" max="8" step="1" value={downscale} onChange={(e) => setDownscale(parseInt(e.target.value))} />
            </div>
          } />

          <ControlSlider id="pixelSort" title="Pixel Sort" value={pixelSort} onChange={setPixelSort} icon={ArrowRight} extra={
            <div className="slider-container">
              <div className="slider-label"><span>Threshold</span><span>{pixelSort.threshold}%</span></div>
              <input type="range" value={pixelSort.threshold} onChange={(e) => setPixelSort({ ...pixelSort, threshold: parseInt(e.target.value) })} />
            </div>
          } />

          <ControlSlider id="retro" title="Dither Strength" value={retro} onChange={setRetro} icon={Activity} />
          <ControlSlider id="crt" title="CRT Scanlines" value={crt} onChange={setCrt} icon={Tv} />
          <ControlSlider id="glow" title="Phosphor Glow" value={glow} onChange={setGlow} icon={Zap} />
          <div className="control-group">
            <h3><Activity size={14} /> Utility</h3>
            <div className="slider-container"><div className="slider-label"><span>Noisy Glitch</span><span>{glitch.start}%</span></div><input type="range" value={glitch.start} onChange={(e) => setGlitch({ ...glitch, start: parseInt(e.target.value), end: parseInt(e.target.value) })} /></div>
            <div className="slider-container"><div className="slider-label"><span>Painterly</span><span>{painterly.start}%</span></div><input type="range" value={painterly.start} onChange={(e) => setPainterly({ ...painterly, start: parseInt(e.target.value), end: parseInt(e.target.value) })} /></div>
          </div>
          <button className="action-button" disabled={!originalGif || isProcessing} onClick={processGif}>{isProcessing ? 'Processing...' : 'Run Lab'}</button>
          {outputGif && <a href={outputGif} download="dithered.gif" className="action-button" style={{ textAlign: 'center', textDecoration: 'none', background: 'var(--primary-color)', color: 'black' }}>Download Result <Download size={16} /></a>}
        </aside>
      </main>
      <AnimatePresence>{status && <motion.div initial={{ y: 50, opacity: 0 }} animate={{ y: 0, opacity: 1 }} exit={{ y: 50, opacity: 0 }} className="status-toast"><div className="status-dot"></div>{status}</motion.div>}</AnimatePresence>
    </div>
  );
}
</file>

</files>
